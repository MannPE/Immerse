import { matchPath, matchesAreEqual } from '../../utils/match-path';
import ActiveRouter from '../../global/active-router';
/**
  * @name Route
  * @module ionic
  * @description
 */
export class Route {
    constructor() {
        this.group = null;
        this.groupMatch = null;
        this.componentUpdated = null;
        this.match = null;
        this.unsubscribe = () => { return; };
        this.componentProps = {};
        this.exact = false;
        this.routeRender = null;
        this.scrollTopOffset = null;
        this.scrollOnNextRender = false;
        this.previousMatch = null;
    }
    // Identify if the current route is a match.
    computeMatch() {
        this.previousMatch = this.match;
        if (!this.group) {
            return this.match = matchPath(this.location.pathname, {
                path: this.url,
                exact: this.exact,
                strict: true
            });
        }
        // If this already matched then lets check if it still matches the
        // updated location.
        if (this.groupMatch) {
            return this.match = matchPath(this.location.pathname, {
                path: this.url,
                exact: this.exact,
                strict: true
            });
        }
    }
    componentDidUpdate() {
        // Wait for all children to complete rendering before calling componentUpdated
        Promise.all(Array.from(this.el.children).map((element) => {
            if (element.componentOnReady) {
                return element.componentOnReady();
            }
            return Promise.resolve(element);
        }))
            .then(() => {
            // After all children have completed then tell switch
            // the provided callback will get executed after this route is in view
            if (typeof this.componentUpdated === 'function') {
                this.componentUpdated({
                    scrollTopOffset: this.scrollTopOffset
                });
                // If this is an independent route and it matches then routes have updated.
                // If the only change to location is a hash change then do not scroll.
            }
            else if (this.match && !matchesAreEqual(this.match, this.previousMatch)) {
                this.routeViewsUpdated({
                    scrollTopOffset: this.scrollTopOffset
                });
            }
        });
    }
    render() {
        // If there is no activeRouter then do not render
        // Check if this route is in the matching URL (for example, a parent route)
        if (!this.match) {
            return null;
        }
        // component props defined in route
        // the history api
        // current match data including params
        const childProps = Object.assign({}, this.componentProps, { history: this.history, match: this.match });
        // If there is a routerRender defined then use
        // that and pass the component and component props with it.
        if (this.routeRender) {
            return this.routeRender(Object.assign({}, childProps, { component: this.component }));
        }
        if (this.component) {
            const ChildComponent = this.component;
            return (h(ChildComponent, Object.assign({}, childProps)));
        }
    }
    static get is() { return "stencil-route"; }
    static get properties() { return {
        "component": {
            "type": String,
            "attr": "component"
        },
        "componentProps": {
            "type": "Any",
            "attr": "component-props"
        },
        "componentUpdated": {
            "type": "Any",
            "attr": "component-updated"
        },
        "el": {
            "elementRef": true
        },
        "exact": {
            "type": Boolean,
            "attr": "exact"
        },
        "group": {
            "type": String,
            "attr": "group"
        },
        "groupMatch": {
            "type": "Any",
            "attr": "group-match"
        },
        "history": {
            "type": "Any",
            "attr": "history"
        },
        "historyType": {
            "type": String,
            "attr": "history-type"
        },
        "location": {
            "type": "Any",
            "attr": "location",
            "watchCallbacks": ["computeMatch"]
        },
        "match": {
            "state": true
        },
        "routeRender": {
            "type": "Any",
            "attr": "route-render"
        },
        "routeViewsUpdated": {
            "type": "Any",
            "attr": "route-views-updated"
        },
        "scrollTopOffset": {
            "type": Number,
            "attr": "scroll-top-offset"
        },
        "url": {
            "type": String,
            "attr": "url"
        }
    }; }
    static get style() { return "/**style-placeholder:stencil-route:**/"; }
}
ActiveRouter.injectProps(Route, [
    'location',
    'history',
    'historyType',
    'routeViewsUpdated'
]);
